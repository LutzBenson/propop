---
title: "Distribute migration"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Distribute migration}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 84
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(propop)
```

# Overview

The FSO (Federal Statistical Office) provides estimates for how many people of different demographic groups (age x sex x nationality) will immigrate to cantons from

- other countries (international immigration),

- other cantons (intercantonal immigration).

A crucial task for the cantonal projection is to allocate the immigration to the spatial entities in the canton (e.g. municipalities, districts).

To distribute the immigration, we multiply the absolute numbers of people with each spatial unitâ€™s share. The shares are expected to capture temporarily stable immigration patterns and are used as reference point to determine how much of the future immigration should be allocated to which spatial unit. The computed share is constant for each demographic group and spatial unit (identical for projection scenarios, and projection years). 

Shares can be obtained by different methods. Here, we exemplify two approaches to calculate shares based on a) population size, and b) historical mutation data. The distribution of the total number of international immigrants (`imm_int_n`) will be used as an example. For this, we create a dataset using the FSO-parameters for international immigration. The column `imm_int_n` contains the original value for international immigration. Prior to distributing, this value is identical for demographic groups within spatial units:

```{r parameters-subregional}
# fso parameters for fictitious subregions
fso_parameters_sub <- fso_parameters |>
  # duplicating rows 5 times
  tidyr::uncount(5) |>
  # create 5 subregions
  dplyr::mutate(spatial_unit = rep(1:5, times = nrow(fso_parameters))) |>
  dplyr::mutate(spatial_unit = as.character(spatial_unit)) |>
  dplyr::select(year, spatial_unit, scen, nat, age, sex, imm_int_n)

fso_parameters_sub |>
  dplyr::filter(sex == "m" & nat == "int") |>
  DT::datatable() |>
  DT::formatStyle(
  "imm_int_n",
  backgroundColor = "#ffcc8f"
)
```

# Distribution based on population size

A simple approach to distribute international immigrants is to calculate shares based on population size of spatial units relative to total population size. Larger spatial units receive a larger portion of the total number of people, while smaller units receive less people. 

The required data contains the number of people (`n`) per demographic group and spatial unit. Here, the start year's population is used and split into five fictious subregional units:

```{r data-population}
# Generate population data for five subregions
df_population <- fso_population |>
  # duplicating rows 5 times
  tidyr::uncount(5) |>
  # create 5 subregions
  dplyr::mutate(spatial_unit = as.character(rep(1:5, times = nrow(fso_population)))) |>
  dplyr::mutate(
    # Create fictitious n
    n = dplyr::case_match(
      spatial_unit,
      "1" ~ round(n * 0.3),
      "2" ~ round(n * 0.25),
      "3" ~ round(n * 0.2),
      "4" ~ round(n * 0.15),
      "5" ~ round(n * 0.1),
      .default = NA
    ),
    .keep = "all"
  )
```

To calculate the shares, we summarize the number of people per demographic group across all spatial units (`sum_n`). Secondly, the share (`share_migration`) is obtained from diving the spatial unit's `n` by the sum (`sum_n`).  

```{r shares-pop-size}
df_population_shares <- df_population |> 
  dplyr::mutate(sum_n = sum(n), .by = c(year, nat, sex, age)) |> 
  dplyr::mutate(share_migration = n / sum_n)
```

Now, all data requirements are met and we can distribute the international migration. For that, `fso_parameters_sub` is joined with the previously created object containing the shares (`df_population_shares`). Identifiers for demographic groups must be present in both datasets. The calculation involves only a single line where the original FSO-parameter (`imm_int_n`) is multiplied by the share (`share_migration`).

```{r distribute-pop-size}
data_distr_pop_size = fso_parameters_sub |> 
  dplyr::left_join(
    df_population_shares[c(
      "spatial_unit", "nat", "sex", "age", "share_migration"
    )],
    by = c("spatial_unit", "nat", "sex", "age"),
    relationship = "many-to-one"
  ) |> 
  dplyr::mutate(imm_int_n_distr = imm_int_n * share_migration) 
```

The blue columns `check` and `difference` show us that the sum of the distributed parameter adds up to the total number of people, originally from the FSO. Consequently, the calculations did not alter the total number of people, which reflects the desired result.

```{r distr-pop-size-check}
data_distr_pop_size |> 
  dplyr::mutate(check = round(sum(imm_int_n_distr), 0), .by = c(year, nat, sex, age)) |> 
  dplyr::filter(sex == "m" & nat == "int") |>
  dplyr::mutate(across(c("share_migration", "imm_int_n_distr"), \(x) round(x, 3))) |> 
  dplyr::mutate(difference = imm_int_n - check) |> 
  DT::datatable() |> 
  DT::formatStyle(
  "imm_int_n",
  backgroundColor = "#ffcc8f"
) |> 
  DT::formatStyle(
  c("check", "difference"),
  backgroundColor = "#96D4FF"
) 
```

To proceed with the projection, the column with the distributed international immigration (`imm_int_n_distr`) becomes the new `imm_int` to be correctly recognized by `propop()`. 

# Distribution based on historical mutation data

We create a fictious dataset which contains the historical number of observed mutations for international immigration for each demographic group and five exemplary spatial units. With real data, the same can be achieved by summarizing the historical mutation data accordingly. Since real mutation occurrences normally vary from year to year, we advise to calculate an average across several years. The fictious data assumes that we already performed this step: 

```{r data}
set.seed(145)

# Historical observations for international immigration
df_hist_imm_int <- tibble::tibble(
  # five fictitious spatial units
  spatial_unit = rep(c("1", "2", "3", "4", "5"), each = 101 * 4), 
  # two nationalities
  nat = rep(rep(c("ch", "int"), each = 2 * 101), times = 5), 
  # two levels for sex
  sex = rep(rep(c("m", "f"), each = 101), times = 5 * 2), 
  # age groups from 0 to 100
  age = rep(0:100, times = 5 * 4) 
) |>
  dplyr::mutate(
    # random numbers between zero and 50 are created to mimic observed 
    # historical occurences for international immigration
    hist_imm_int = sample(0:50, dplyr::n(), replace = TRUE),
    # for one spatial unit, we artificially assign zeros to all children 
    # between 0-4 years
    hist_imm_int = ifelse(spatial_unit == 1 & age %in% c(0:4), 0, hist_imm_int)
  )
```

For this example, we modify the data a little bit: for one of the spatial units (`spatial_unit == "1"`), children aged 0-4 years there aren't any no observations for international immigrants. Consequently, the value in the column `hist_imm_int` contains zeros for these entries. This does not reflect realistic conditions but helps to illustrate the procedure in cases where zero observations exist for demographic groups. The data looks like this:

```{r data-historical-immigration}
df_hist_imm_int |> 
  DT::datatable()
```

# Calculating historical shares

To calculate the historical shares, we apply the function `propop::calculate_shares()`, passing our data's column of interest to the mandatory function argument `column_migration = hist_imm_int`. The function uses the historical share if values above zero exist for demographic groups. In cases where no mutations were observed, a proportional average across an age range is used (e.g. 5-year or 10-year average). Here, we used the proportional average across 10-year age groups for demographic groups with zero mutations. 

```{r result-historical-immigration}
data_distr_hist <- df_hist_imm_int |> 
  calculate_shares(column_migration = "hist_imm_int")

data_distr_hist |> 
  dplyr::mutate(share_migration = round(share_migration, 3)) |> 
  DT::datatable() |> 
  DT::formatStyle(
  "estimate_mig",
  backgroundColor = "#ffcc8f"
) 
```

From now on, the procedure is identical to the above explained distribution based on population size. 

```{r parameters-distributed}
fso_parameters_sub_distr_hist = fso_parameters_sub |> 
  dplyr::left_join(
    data_distr_hist[c(
      "spatial_unit", "nat", "sex", "age", "share_migration"
    )],
    by = c("spatial_unit", "nat", "sex", "age"),
    relationship = "many-to-one"
  ) |> 
  dplyr::mutate(imm_int_n_distr = imm_int_n * share_migration) 
```

# Outlook

*The procedure works likewise for the intercantonal immigration. For subregional migration saldos (e.g. movements between municipalities/districts) the function `calculate_share()` is applied twice: to calculate subregional immigration shares and secondly, emigration shares.* 

# Draft: Next steps
-   **Historical shares:** refinement for groups with zero historical observations; e.g. using not only 1-year and 10-year groups but also 5-year groups or even more elaborate age groups such as life stages.

-   **Arrange vignettes**: Separate vignettes into a) projection for a single region (`subregional = FALSE`) and b) projection for several subregions (`subregional = TRUE`). 


