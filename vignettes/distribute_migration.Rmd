---
title: "Distribute migration"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Distribute migration}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 84
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(propop)
```

# Overview

The FSO (Federal Statistical Office) provides estimates for how many people of different demographic groups (age x sex x nationality) will immigrate to cantons from

- other countries (international immigration),

- other cantons (intercantonal immigration).

A crucial task for the cantonal projection is to allocate the immigration to the spatial entities in the canton (e.g. municipalities, districts).

To distribute the immigration, we multiply the absolute numbers of people with each spatial unitâ€™s average historical share. The historical shares are expected to capture temporarily stable immigration patterns and are used as reference point to determine how much of the future immigration should be allocated to which spatial unit. The computed share is constant for each demographic group and spatial unit (identical for projection scenarios, and projection years). 

# Example: Distributing the international immigration

We create a fictious dataset which contains the historical number of observed mutations for international immigration for each demographic group and five exemplary spatial units. With real data, the same can be achieved by summarizing the historical mutation data accordingly. Since real mutation occurences normally vary from year to year. Therefore, we advise to calculate an average across several years. The fictious data assumes that we already performed this step. 

```{r data}
set.seed(145)

# Historical observations for international immigration
df_hist_imm_int <- tibble::tibble(
  # five fictitious spatial units
  spatial_unit = rep(c("1", "2", "3", "4", "5"), each = 101 * 4), 
  # two nationalities
  nat = rep(rep(c("ch", "int"), each = 2 * 101), times = 5), 
  # two levels for sex
  sex = rep(rep(c("m", "f"), each = 101), times = 5 * 2), 
  # age groups from 0 to 100
  age = rep(0:100, times = 5 * 4) 
) |>
  dplyr::mutate(
    # random numbers between zero and 50 are created to mimic observed 
    # historical occurences for international immigration
    hist_imm_int = sample(0:50, dplyr::n(), replace = TRUE),
    # for one spatial unit, we artificially assign zeros to all children 
    # between 0-4 years
    hist_imm_int = ifelse(spatial_unit == 1 & age %in% c(0:4), 0, hist_imm_int)
  )
```

In this example, we artificially define no occurences of international immigration for all children in the age range of 0-4 years for a single spatial unit. The value in the column `hist_imm_int` contains zeros for these entries. This does not reflect realistic conditions but helps to illustrate the procedure in cases where zero observations exist for demographic groups. The data looks like this:

```{r data-historical-immigration}
df_hist_imm_int |> 
  DT::datatable()
```

# Calculating historical shares

To calculate the shares, we apply the function `propop::calculate_shares()` passing our data's column of interest `hist_imm_int` to the mandatory function argument `column_migration =`. The function uses the historical share if values above zero exist for demographic groups. In cases where no mutations were observed, a proportional average across an age range is used (e.g. 5-year or 10-year average). Here, we used the proportional average across 10-year age groups for demographic groups with zero mutations. 

```{r result-historical-immigration}
df_hist_imm_int_result <- df_hist_imm_int |> 
  calculate_shares(column_migration = "hist_imm_int")

df_hist_imm_int_result |> 
  mutate(share_migration = round(share_migration, 3)) |> 
  DT::datatable() |> 
  DT::formatStyle(
  "estimate_mig",
  backgroundColor = "#ffcc8f"
) 
```


# Distribution based on historical shares

To demonstrate the distribution of the parameter for international immigration (from the FSO), we create another fictious dataset with demographic groups, spatial unit and the respective column `imm_int_n`. The column `imm_int_n` contains the original value for international immigration and they value is identical for demographic groups within spatial units.

```{r parameters-subregional}
# fso parameters for fictitious subregions
fso_parameters_sub <- fso_parameters |>
  # duplicating rows 5 times
  tidyr::uncount(5) |>
  # create 5 subregions
  dplyr::mutate(spatial_unit = rep(1:5, times = nrow(fso_parameters))) |>
  dplyr::mutate(spatial_unit = as.character(spatial_unit)) |> 
  dplyr::select(year, spatial_unit, scen, nat, age, sex, imm_int_n)

fso_parameters_sub |> 
  dplyr::filter(sex == "m" & nat == "int") |>
  DT::datatable() |> 
  DT::formatStyle(
  "imm_int_n",
  backgroundColor = "#ffcc8f"
) 
```

Now we can distribute the international migration among spatial units using our pre-calculated share. For that, the data original is joined with the previously created object containing the shares (`df_hist_imm_int_result`). Identifiers for demographic groups must be present in both datasets. The calculation involves only a single line where the original FSO-parameter `imm_int_n` is multiplied by the share `share_migration`.

```{r parameters-distributed}
fso_parameters_sub_distr = fso_parameters_sub |> 
  dplyr::left_join(
    df_hist_imm_int_result[c(
      "spatial_unit", "nat", "sex", "age", "share_migration"
    )],
    by = c("spatial_unit", "nat", "sex", "age"),
    relationship = "many-to-one"
  ) |> 
  dplyr::mutate(imm_int_n_distr = imm_int_n * share_migration) 
  
```

The blue columns `check` and `difference` show us that the sum of the distributed parameter adds up to the total number of people, originally from the FSO. Consequently, the calculations did not alter the total number of people, which is the desired result.

```{r parameters-distributed-check}
fso_parameters_sub_distr |> 
  mutate(check = round(sum(imm_int_n_distr), 0), .by = c(year, nat, sex, age)) |> 
  dplyr::filter(sex == "m" & nat == "int") |>
  mutate(across(c("share_migration", "imm_int_n_distr"), \(x) round(x, 3))) |> 
  mutate(difference = imm_int_n - check) |> 
  DT::datatable() |> 
  DT::formatStyle(
  "imm_int_n",
  backgroundColor = "#ffcc8f"
) |> 
  DT::formatStyle(
  c("check", "difference"),
  backgroundColor = "#96D4FF"
) 
```

To proceed, the column with the distributed international immigration has to be renamed `imm_int` to be correctly recognized by `propop()` as the input column for this parameter. The procedure works likewise for the intercantonal immigration. It is also possible to calculate the subregional migration saldo this way (e.g. movements between municipalities/districts). For that, the function `calculate_share()` is applied twice: to calculate subregional immigration shares and secondly, emigration shares. 

